{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\nconst asn1 = require('asn1.js');\nconst jws = require('jws');\nconst {\n  URL\n} = require('url');\nconst WebPushConstants = require('./web-push-constants.js');\nconst urlBase64Helper = require('./urlsafe-base64-helper');\n\n/**\n * DEFAULT_EXPIRATION is set to seconds in 12 hours\n */\nconst DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;\n\n// Maximum expiration is 24 hours according. (See VAPID spec)\nconst MAX_EXPIRATION_SECONDS = 24 * 60 * 60;\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').explicit(0).objid().optional(), this.key('publicKey').explicit(1).bitstr().optional());\n});\nfunction toPEM(key) {\n  return ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key,\n    parameters: [1, 2, 840, 10045, 3, 1, 7] // prime256v1\n  }, 'pem', {\n    label: 'EC PRIVATE KEY'\n  });\n}\nfunction generateVAPIDKeys() {\n  const curve = crypto.createECDH('prime256v1');\n  curve.generateKeys();\n  let publicKeyBuffer = curve.getPublicKey();\n  let privateKeyBuffer = curve.getPrivateKey();\n\n  // Occassionally the keys will not be padded to the correct lengh resulting\n  // in errors, hence this padding.\n  // See https://github.com/web-push-libs/web-push/issues/295 for history.\n  if (privateKeyBuffer.length < 32) {\n    const padding = Buffer.alloc(32 - privateKeyBuffer.length);\n    padding.fill(0);\n    privateKeyBuffer = Buffer.concat([padding, privateKeyBuffer]);\n  }\n  if (publicKeyBuffer.length < 65) {\n    const padding = Buffer.alloc(65 - publicKeyBuffer.length);\n    padding.fill(0);\n    publicKeyBuffer = Buffer.concat([padding, publicKeyBuffer]);\n  }\n  return {\n    publicKey: publicKeyBuffer.toString('base64url'),\n    privateKey: privateKeyBuffer.toString('base64url')\n  };\n}\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('No subject set in vapidDetails.subject.');\n  }\n  if (typeof subject !== 'string' || subject.length === 0) {\n    throw new Error('The subject value must be a string containing an https: URL or ' + 'mailto: address. ' + subject);\n  }\n  let subjectParseResult = null;\n  try {\n    subjectParseResult = new URL(subject);\n  } catch (err) {\n    throw new Error('Vapid subject is not a valid URL. ' + subject);\n  }\n  if (!['https:', 'mailto:'].includes(subjectParseResult.protocol)) {\n    throw new Error('Vapid subject is not an https: or mailto: URL. ' + subject);\n  }\n  if (subjectParseResult.hostname === 'localhost') {\n    console.warn('Vapid subject points to a localhost web URI, which is unsupported by ' + 'Apple\\'s push notification server and will result in a BadJwtToken error when ' + 'sending notifications.');\n  }\n}\nfunction validatePublicKey(publicKey) {\n  if (!publicKey) {\n    throw new Error('No key set vapidDetails.publicKey');\n  }\n  if (typeof publicKey !== 'string') {\n    throw new Error('Vapid public key is must be a URL safe Base 64 ' + 'encoded string.');\n  }\n  if (!urlBase64Helper.validate(publicKey)) {\n    throw new Error('Vapid public key must be a URL safe Base 64 (without \"=\")');\n  }\n  publicKey = Buffer.from(publicKey, 'base64url');\n  if (publicKey.length !== 65) {\n    throw new Error('Vapid public key should be 65 bytes long when decoded.');\n  }\n}\nfunction validatePrivateKey(privateKey) {\n  if (!privateKey) {\n    throw new Error('No key set in vapidDetails.privateKey');\n  }\n  if (typeof privateKey !== 'string') {\n    throw new Error('Vapid private key must be a URL safe Base 64 ' + 'encoded string.');\n  }\n  if (!urlBase64Helper.validate(privateKey)) {\n    throw new Error('Vapid private key must be a URL safe Base 64 (without \"=\")');\n  }\n  privateKey = Buffer.from(privateKey, 'base64url');\n  if (privateKey.length !== 32) {\n    throw new Error('Vapid private key should be 32 bytes long when decoded.');\n  }\n}\n\n/**\n * Given the number of seconds calculates\n * the expiration in the future by adding the passed `numSeconds`\n * with the current seconds from Unix Epoch\n *\n * @param {Number} numSeconds Number of seconds to be added\n * @return {Number} Future expiration in seconds\n */\nfunction getFutureExpirationTimestamp(numSeconds) {\n  const futureExp = new Date();\n  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);\n  return Math.floor(futureExp.getTime() / 1000);\n}\n\n/**\n * Validates the Expiration Header based on the VAPID Spec\n * Throws error of type `Error` if the expiration is not validated\n *\n * @param {Number} expiration Expiration seconds from Epoch to be validated\n */\nfunction validateExpiration(expiration) {\n  if (!Number.isInteger(expiration)) {\n    throw new Error('`expiration` value must be a number');\n  }\n  if (expiration < 0) {\n    throw new Error('`expiration` must be a positive integer');\n  }\n\n  // Roughly checks the time of expiration, since the max expiration can be ahead\n  // of the time than at the moment the expiration was generated\n  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);\n  if (expiration >= maxExpirationTimestamp) {\n    throw new Error('`expiration` value is greater than maximum of 24 hours');\n  }\n}\n\n/**\n * This method takes the required VAPID parameters and returns the required\n * header to be added to a Web Push Protocol Request.\n * @param  {string} audience        This must be the origin of the push service.\n * @param  {string} subject         This should be a URL or a 'mailto:' email\n * address.\n * @param  {string} publicKey       The VAPID public key.\n * @param  {string} privateKey      The VAPID private key.\n * @param  {string} contentEncoding The contentEncoding type.\n * @param  {integer} [expiration]   The expiration of the VAPID JWT.\n * @return {Object}                 Returns an Object with the Authorization and\n * 'Crypto-Key' values to be used as headers.\n */\nfunction getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {\n  if (!audience) {\n    throw new Error('No audience could be generated for VAPID.');\n  }\n  if (typeof audience !== 'string' || audience.length === 0) {\n    throw new Error('The audience value must be a string containing the ' + 'origin of a push service. ' + audience);\n  }\n  try {\n    new URL(audience); // eslint-disable-line no-new\n  } catch (err) {\n    throw new Error('VAPID audience is not a url. ' + audience);\n  }\n  validateSubject(subject);\n  validatePublicKey(publicKey);\n  validatePrivateKey(privateKey);\n  privateKey = Buffer.from(privateKey, 'base64url');\n  if (expiration) {\n    validateExpiration(expiration);\n  } else {\n    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);\n  }\n  const header = {\n    typ: 'JWT',\n    alg: 'ES256'\n  };\n  const jwtPayload = {\n    aud: audience,\n    exp: expiration,\n    sub: subject\n  };\n  const jwt = jws.sign({\n    header: header,\n    payload: jwtPayload,\n    privateKey: toPEM(privateKey)\n  });\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {\n    return {\n      Authorization: 'vapid t=' + jwt + ', k=' + publicKey\n    };\n  }\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {\n    return {\n      Authorization: 'WebPush ' + jwt,\n      'Crypto-Key': 'p256ecdsa=' + publicKey\n    };\n  }\n  throw new Error('Unsupported encoding type specified.');\n}\nmodule.exports = {\n  generateVAPIDKeys: generateVAPIDKeys,\n  getFutureExpirationTimestamp: getFutureExpirationTimestamp,\n  getVapidHeaders: getVapidHeaders,\n  validateSubject: validateSubject,\n  validatePublicKey: validatePublicKey,\n  validatePrivateKey: validatePrivateKey,\n  validateExpiration: validateExpiration\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
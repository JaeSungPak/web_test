{"ast":null,"code":"'use strict';\n\nconst url = require('url');\nconst https = require('https');\nconst WebPushError = require('./web-push-error.js');\nconst vapidHelper = require('./vapid-helper.js');\nconst encryptionHelper = require('./encryption-helper.js');\nconst webPushConstants = require('./web-push-constants.js');\nconst urlBase64Helper = require('./urlsafe-base64-helper');\n\n// Default TTL is four weeks.\nconst DEFAULT_TTL = 2419200;\nlet gcmAPIKey = '';\nlet vapidDetails;\nfunction WebPushLib() {}\n\n/**\n * When sending messages to a GCM endpoint you need to set the GCM API key\n * by either calling setGMAPIKey() or passing in the API key as an option\n * to sendNotification().\n * @param  {string} apiKey The API key to send with the GCM request.\n */\nWebPushLib.prototype.setGCMAPIKey = function (apiKey) {\n  if (apiKey === null) {\n    gcmAPIKey = null;\n    return;\n  }\n  if (typeof apiKey === 'undefined' || typeof apiKey !== 'string' || apiKey.length === 0) {\n    throw new Error('The GCM API Key should be a non-empty string or null.');\n  }\n  gcmAPIKey = apiKey;\n};\n\n/**\n * When making requests where you want to define VAPID details, call this\n * method before sendNotification() or pass in the details and options to\n * sendNotification.\n * @param  {string} subject    This must be either a URL or a 'mailto:'\n * address. For example: 'https://my-site.com/contact' or\n * 'mailto: contact@my-site.com'\n * @param  {string} publicKey  The public VAPID key, a URL safe, base64 encoded string\n * @param  {string} privateKey The private VAPID key, a URL safe, base64 encoded string.\n */\nWebPushLib.prototype.setVapidDetails = function (subject, publicKey, privateKey) {\n  if (arguments.length === 1 && arguments[0] === null) {\n    vapidDetails = null;\n    return;\n  }\n  vapidHelper.validateSubject(subject);\n  vapidHelper.validatePublicKey(publicKey);\n  vapidHelper.validatePrivateKey(privateKey);\n  vapidDetails = {\n    subject: subject,\n    publicKey: publicKey,\n    privateKey: privateKey\n  };\n};\n\n/**\n * To get the details of a request to trigger a push message, without sending\n * a push notification call this method.\n *\n * This method will throw an error if there is an issue with the input.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Object}                       This method returns an Object which\n * contains 'endpoint', 'method', 'headers' and 'payload'.\n */\nWebPushLib.prototype.generateRequestDetails = function (subscription, payload, options) {\n  if (!subscription || !subscription.endpoint) {\n    throw new Error('You must pass in a subscription with at least ' + 'an endpoint.');\n  }\n  if (typeof subscription.endpoint !== 'string' || subscription.endpoint.length === 0) {\n    throw new Error('The subscription endpoint must be a string with ' + 'a valid URL.');\n  }\n  if (payload) {\n    // Validate the subscription keys\n    if (typeof subscription !== 'object' || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {\n      throw new Error('To send a message with a payload, the ' + 'subscription must have \\'auth\\' and \\'p256dh\\' keys.');\n    }\n  }\n  let currentGCMAPIKey = gcmAPIKey;\n  let currentVapidDetails = vapidDetails;\n  let timeToLive = DEFAULT_TTL;\n  let extraHeaders = {};\n  let contentEncoding = webPushConstants.supportedContentEncodings.AES_128_GCM;\n  let urgency = webPushConstants.supportedUrgency.NORMAL;\n  let topic;\n  let proxy;\n  let agent;\n  let timeout;\n  if (options) {\n    const validOptionKeys = ['headers', 'gcmAPIKey', 'vapidDetails', 'TTL', 'contentEncoding', 'urgency', 'topic', 'proxy', 'agent', 'timeout'];\n    const optionKeys = Object.keys(options);\n    for (let i = 0; i < optionKeys.length; i += 1) {\n      const optionKey = optionKeys[i];\n      if (!validOptionKeys.includes(optionKey)) {\n        throw new Error('\\'' + optionKey + '\\' is an invalid option. ' + 'The valid options are [\\'' + validOptionKeys.join('\\', \\'') + '\\'].');\n      }\n    }\n    if (options.headers) {\n      extraHeaders = options.headers;\n      let duplicates = Object.keys(extraHeaders).filter(function (header) {\n        return typeof options[header] !== 'undefined';\n      });\n      if (duplicates.length > 0) {\n        throw new Error('Duplicated headers defined [' + duplicates.join(',') + ']. Please either define the header in the' + 'top level options OR in the \\'headers\\' key.');\n      }\n    }\n    if (options.gcmAPIKey) {\n      currentGCMAPIKey = options.gcmAPIKey;\n    }\n\n    // Falsy values are allowed here so one can skip Vapid `else if` below and use FCM\n    if (options.vapidDetails !== undefined) {\n      currentVapidDetails = options.vapidDetails;\n    }\n    if (options.TTL !== undefined) {\n      timeToLive = Number(options.TTL);\n      if (timeToLive < 0) {\n        throw new Error('TTL should be a number and should be at least 0');\n      }\n    }\n    if (options.contentEncoding) {\n      if (options.contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM || options.contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        contentEncoding = options.contentEncoding;\n      } else {\n        throw new Error('Unsupported content encoding specified.');\n      }\n    }\n    if (options.urgency) {\n      if (options.urgency === webPushConstants.supportedUrgency.VERY_LOW || options.urgency === webPushConstants.supportedUrgency.LOW || options.urgency === webPushConstants.supportedUrgency.NORMAL || options.urgency === webPushConstants.supportedUrgency.HIGH) {\n        urgency = options.urgency;\n      } else {\n        throw new Error('Unsupported urgency specified.');\n      }\n    }\n    if (options.topic) {\n      if (!urlBase64Helper.validate(options.topic)) {\n        throw new Error('Unsupported characters set use the URL or filename-safe Base64 characters set');\n      }\n      if (options.topic.length > 32) {\n        throw new Error('use maximum of 32 characters from the URL or filename-safe Base64 characters set');\n      }\n      topic = options.topic;\n    }\n    if (options.proxy) {\n      if (typeof options.proxy === 'string' || typeof options.proxy.host === 'string') {\n        proxy = options.proxy;\n      } else {\n        console.warn('Attempt to use proxy option, but invalid type it should be a string or proxy options object.');\n      }\n    }\n    if (options.agent) {\n      if (options.agent instanceof https.Agent) {\n        if (proxy) {\n          console.warn('Agent option will be ignored because proxy option is defined.');\n        }\n        agent = options.agent;\n      } else {\n        console.warn('Wrong type for the agent option, it should be an instance of https.Agent.');\n      }\n    }\n    if (typeof options.timeout === 'number') {\n      timeout = options.timeout;\n    }\n  }\n  if (typeof timeToLive === 'undefined') {\n    timeToLive = DEFAULT_TTL;\n  }\n  const requestDetails = {\n    method: 'POST',\n    headers: {\n      TTL: timeToLive\n    }\n  };\n  Object.keys(extraHeaders).forEach(function (header) {\n    requestDetails.headers[header] = extraHeaders[header];\n  });\n  let requestPayload = null;\n  if (payload) {\n    const encrypted = encryptionHelper.encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);\n    requestDetails.headers['Content-Length'] = encrypted.cipherText.length;\n    requestDetails.headers['Content-Type'] = 'application/octet-stream';\n    if (contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM) {\n      requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_128_GCM;\n    } else if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n      requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_GCM;\n      requestDetails.headers.Encryption = 'salt=' + encrypted.salt;\n      requestDetails.headers['Crypto-Key'] = 'dh=' + encrypted.localPublicKey.toString('base64url');\n    }\n    requestPayload = encrypted.cipherText;\n  } else {\n    requestDetails.headers['Content-Length'] = 0;\n  }\n  const isGCM = subscription.endpoint.startsWith('https://android.googleapis.com/gcm/send');\n  const isFCM = subscription.endpoint.startsWith('https://fcm.googleapis.com/fcm/send');\n  // VAPID isn't supported by GCM hence the if, else if.\n  if (isGCM) {\n    if (!currentGCMAPIKey) {\n      console.warn('Attempt to send push notification to GCM endpoint, ' + 'but no GCM key is defined. Please use setGCMApiKey() or add ' + '\\'gcmAPIKey\\' as an option.');\n    } else {\n      requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n    }\n  } else if (currentVapidDetails) {\n    const parsedUrl = url.parse(subscription.endpoint);\n    const audience = parsedUrl.protocol + '//' + parsedUrl.host;\n    const vapidHeaders = vapidHelper.getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);\n    requestDetails.headers.Authorization = vapidHeaders.Authorization;\n    if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n      if (requestDetails.headers['Crypto-Key']) {\n        requestDetails.headers['Crypto-Key'] += ';' + vapidHeaders['Crypto-Key'];\n      } else {\n        requestDetails.headers['Crypto-Key'] = vapidHeaders['Crypto-Key'];\n      }\n    }\n  } else if (isFCM && currentGCMAPIKey) {\n    requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n  }\n  requestDetails.headers.Urgency = urgency;\n  if (topic) {\n    requestDetails.headers.Topic = topic;\n  }\n  requestDetails.body = requestPayload;\n  requestDetails.endpoint = subscription.endpoint;\n  if (proxy) {\n    requestDetails.proxy = proxy;\n  }\n  if (agent) {\n    requestDetails.agent = agent;\n  }\n  if (timeout) {\n    requestDetails.timeout = timeout;\n  }\n  return requestDetails;\n};\n\n/**\n * To send a push notification call this method with a subscription, optional\n * payload and any options.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Promise}                       This method returns a Promise which\n * resolves if the sending of the notification was successful, otherwise it\n * rejects.\n */\nWebPushLib.prototype.sendNotification = function (subscription, payload, options) {\n  let requestDetails;\n  try {\n    requestDetails = this.generateRequestDetails(subscription, payload, options);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n  return new Promise(function (resolve, reject) {\n    const httpsOptions = {};\n    const urlParts = url.parse(requestDetails.endpoint);\n    httpsOptions.hostname = urlParts.hostname;\n    httpsOptions.port = urlParts.port;\n    httpsOptions.path = urlParts.path;\n    httpsOptions.headers = requestDetails.headers;\n    httpsOptions.method = requestDetails.method;\n    if (requestDetails.timeout) {\n      httpsOptions.timeout = requestDetails.timeout;\n    }\n    if (requestDetails.agent) {\n      httpsOptions.agent = requestDetails.agent;\n    }\n    if (requestDetails.proxy) {\n      const {\n        HttpsProxyAgent\n      } = require('https-proxy-agent'); // eslint-disable-line global-require\n      httpsOptions.agent = new HttpsProxyAgent(requestDetails.proxy);\n    }\n    const pushRequest = https.request(httpsOptions, function (pushResponse) {\n      let responseText = '';\n      pushResponse.on('data', function (chunk) {\n        responseText += chunk;\n      });\n      pushResponse.on('end', function () {\n        if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {\n          reject(new WebPushError('Received unexpected response code', pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));\n        } else {\n          resolve({\n            statusCode: pushResponse.statusCode,\n            body: responseText,\n            headers: pushResponse.headers\n          });\n        }\n      });\n    });\n    if (requestDetails.timeout) {\n      pushRequest.on('timeout', function () {\n        pushRequest.destroy(new Error('Socket timeout'));\n      });\n    }\n    pushRequest.on('error', function (e) {\n      reject(e);\n    });\n    if (requestDetails.body) {\n      pushRequest.write(requestDetails.body);\n    }\n    pushRequest.end();\n  });\n};\nmodule.exports = WebPushLib;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}